# LPOO1617_T3G4_GravityGuy

## Final Project Intermediate Check-Point:

### 1. Architecture Design
 * **1. Class Diagram Documentation**
![UML](https://cloud.githubusercontent.com/assets/19241121/25565541/8b538998-2dc0-11e7-88d5-7e167c0265be.jpg)
 	* **EntityModel**: An abstract model representing an entity which belongs to a game model. Stores the position of the model.
	* **PlayerModel**: A concrete model representing a player. Stores the state of the player model, used to determine the consequence of inputs.
	* **BlockModel**: A concrete model representing a block.
	* **GameModel**: A model that represents the game. Stores the player model and the block models which constitute the level.
	* **EntityBody**: An abstract class that wraps the Body class, the body generated by the concrete classes have a custom BodyDef and Fixture. The concrete classes must implement the methods that generate them.
	* **PlayerBody**: A concrete body that represents the player body.
	* **BlockBody**: A concrete body that represents the block body.
	* **GameController**: Controls the physics engine of the game. Stores the world,player body and blocks body. Handles the collisions and compares the bodies’ positionto the viewport bounds.
	* **EntityView**: An abstract view which holds a sprite with a certain position and image. The class is responsible for updating the sprite position based on an EntityModel’s position and for the drawing of the sprite.
	* **PlayerView**: A concrete view that loads the player image to the sprite.
	* **BodyView**: A concrete view that loads the block image to the sprite.
	* **GameView**: A view representing the game screen. Draws all the entity views, controls the camera and handles the game input.
	* **MenuView**: A view representing the menu screen. Draws all the buttons and handles the menu input.
	* **GravityGuy**: The game’s main class. It’s responsible for the loading of assets and setting the screens.
	
	
 * **2. Dynamic Diagram Documentation**
![Dynamic Diagram](https://cloud.githubusercontent.com/assets/19241121/25565542/8cf29be0-2dc0-11e7-9bc7-9dfe02d4718c.jpg)
 	* **Button Dynamic**  
	When the game is launched, the menu is displayed. The menu has 4 buttons: SinglePlayer, MultiPlayer, Highscores and Exit.  
	A singleplayer game begins after a level being selected.  
	A multiplayer begins after the number of players being selected (since the multiplayer is local and because smartphones’ screens aren’t as big as a computer’s, this defaults to 2).  
	It’s possible to check the highest scores achieved by clicking Highscores.  
	A user can exit as soon as the game starts.  
	Regardless of what game mode the user is playing, it can be paused and, afterwards, resumed. In the pause menu, it’s also possible to exit the game. 

	* **Gameplay Dynamic**  
	When a level starts, the player is running on a block.   
	While running, the user can click the screen, which will cause the player to invert its gravity, making it free fall to the other side. If the user doesn’t click the screen, the player might eventually run out of block tiles and start to fall (corresponds to the end of a collision).   
	While falling, the user has no control over the player, which makes the game more difficult, since the user must predict where the player is going to end up after clicking. A falling player can return to running state if a collision starts, which means the player hit a block (or a player in multiplayer mode).   
	In both states, the player can go out of bounds, meaning the user lost. If the player lost while running, it means the player was too behind (due to colliding horizontally with a block for too long, making it impossible to move forward without clicking the screen). If the player lost while falling, it means the level had no block tile to keep the player inside the map (which can happen due to miscalculating the trajectory of the player). 

 
 * **3. Design Patterns**  
	* **Singleton**: The engines and main class are singletons. This means that GravityGuy, GameModel and GameController will only have one instance which can easily be accessed by each other and by the screens. To implement this, it was decided to use a private member of that class (which starts as null) with a private constructor and a public static getter of the instance (which creates the field if null).  
	* **State**: State is used in the way the user input is processed. The input is received by the GameView and processed in the PlayerModel class. The way it processes it is based on a Deterministic Finite Automata. This makes the code a lot cleaner and less susceptible to bugs when compared to using Booleans for every state possible.  
	* **Update Method**: Since there is no specific hardware targeted when building crossplatform games, a game can run its main loop a different amount of times when comparing to another platform, simply because of its hardware / operating system performance. To ensure that this phenomenon makes the game smoother instead of faster, the update method used in the render function uses the time elapsed since the last frame. This is helpful because the movement can be made proportional to this delta. In our specific case, this will be used in almost everything: updating an entity’s body’s position and consequently its model and view; updating the camera. This is achieved by multiplying the time delta by the velocity, ensuring that smaller time deltas result in smaller movements.  
	* **Pool**: Since the blocks all have the same model, there is no need to be creating and destroying all three classes every time a block runs out of the canvas or a block appears from the other side of the canvas. To do this, it was decided to implement a Pool of BlockModel’s and when a new one is needed, the program will simply check if there is any in the Pool that is not seen anymore and replace it. This can optimize the game’s performance and memory management, since it becomes less fragmented.  
	* **Template**: The template pattern is already used by libgdx, since the GravityGuy class extends Game. The main loop is the same in every game. It runs until the user wants to quit, it handles input, updates the models and renders the displayed frame.  
	* **Double buffer**: The double buffer is one the most used design patterns in video games. If there was only one buffer, flickering would be noticeable since the scene would be rendered in the same buffer that was being displayed. Having two buffers eliminates flickering because, while one is being displayed, the other is being modified. When ready they are swapped. This design pattern is also already implemented in libgdx.  
	* **Observer**: The observer pattern is used to check for user input and check for collisions.
The first is handled in the GameView class by implementing a ClickListener and its touchdown() method. The second is handled in the GameController class by implementing a ContactListener and its beginContact() and endContact() methods.

### 2. GUI Design with Mockups
![Main Menu](https://cloud.githubusercontent.com/assets/19241121/25565401/ef57f47c-2dbd-11e7-918b-e1f079ad204a.png)
![Exit Alert](https://cloud.githubusercontent.com/assets/19241121/25565402/ef5b61a2-2dbd-11e7-9886-15794979c336.png)
  * **Main Menu**
    * SinglePlayer Button – Goes to SinglePlayer Menu
    * MultiPlayer Button – Plays the Game with 2 Players
    * Highscores 
    * Exit Button – Exits the app
     
 
![SinglePlayer Menu](https://cloud.githubusercontent.com/assets/19241121/25565403/ef5d1e8e-2dbd-11e7-8d86-b543a609f5b3.png)
  * **SinglePlayer Menu**
    * Buttons with the level
    * Button to play an endless world

![SinglePlayer Game](https://cloud.githubusercontent.com/assets/19241121/25565404/ef604da2-2dbd-11e7-84c7-c8e6cf615e74.png)
![MultiPlayer Game](https://cloud.githubusercontent.com/assets/19241121/25565400/ef556bf8-2dbd-11e7-9a76-e8b815a96644.png)
![Pause Menu](https://cloud.githubusercontent.com/assets/19241121/25565407/02d08474-2dbe-11e7-9297-06bfc8d93813.png)
![Help Button](https://cloud.githubusercontent.com/assets/19241121/25565409/06fc9150-2dbe-11e7-9c52-4e69ed60e21c.png)
  * **Game** 
	  * Pause Button – Presents a Menu with options like Exit and Continue
	  * Score – Presents the current score (only in SinglePlayer)
	  * Help Button – Presents the basics of the game (like a little tutorial)
	  * If the user clicks changes its gravity with the porpoise of not falling of the world and not to stay blocked and fall behind.

### 3. Test Design
  
  *	Testing the physics collision with the character and a block (square / rectangle)
  *	Testing the change of gravity
  *	Testing the change of gravity with 2 players (shouldn’t affect the other player)
  *	Testing completing a level
  *	Testing the two losing situations (runs into an object and stays behind and fall off the world)
  *	Testing change the gravity while at mid-air


